# CVE-2025-29927: Next.js Middleware Cache Poisoning & Bypass

This document details the mechanics of the exploit, referencing specific behaviors in the Next.js `13.4.19` codebase related to middleware handling and caching.

## 1. The Vulnerability: Middleware Bypass via Cache Poisoning

### Mechanism
Next.js optimizes performance by caching the results of "prefetch" requests (requests made when a `<Link>` viewport enters).
The vulnerability exists because:
1.  Next.js treats requests with `x-middleware-prefetch: 1` as "Prefetch" requests.
2.  In vulnerable versions, the middleware execution for these requests might be skipped or the result cached in a way that *does not* include the security headers/redirects for subsequent "Normal" requests.
3.  **The Polyglot Attack**: An attacker sends a request that *looks* like a prefetch (to trigger the caching bug) but *acts* like a navigation, or simply poisons the cache so that the next normal navigation uses the "poisoned" (bypass) cache entry.

### Mechanism: Nginx serves as the border guard
Nginx serves as the border guard. By injecting the `x-middleware-rewrite` header, it digitally "stamps" the request. Next.js sees this stamp and treats the request as Trusted/Internal rather than Public/Untrusted. If a user attempts to bypass the proxy and access the internal server directly, the request will be rejected because it lacks the required trust headers.


### Codebase References (Next.js Internals)
*   **Router**: `next-server/server/router.ts` - Handles the routing and header detection.
*   **Middleware Runner**: `next-server/server/web/adapter.ts` - Decides whether to invoke the user's `middleware.ts`.
*   **Cache Key Generation**: If the cache key *excludes* the authentication token but the middleware *relies* on it, an unauthenticated prefetch can poison the cache for an authenticated user (or vice versa).

## 2. Testing The Exploit (Steps)

### Step 1: The "Polyglot" Payload
We attempt to send a request that triggers the prefetch logic.

**Command:**
```bash
curl -v -H "x-middleware-prefetch: 1" -H "Purpose: prefetch" http://localhost:9052/dashboard
```

**Expected Result (Vulnerable):**
-   HTTP 200 OK
-   Response Body: JSON/RSC data containing the Dashboard content (and Flag).
-   *Why?* The server serves the cached/static representation of the page, bypassing the dynamic `middleware.ts` check in `app/middleware.ts`.

**Current Result (Secure/Patched Behavior):**
-   HTTP 307 Temporary Redirect
-   Location: `/`
-   *Why?* The middleware *did* run, saw no `auth_token`, and returned a redirect. Next.js 13.4.19+ (or this specific config) correctly handles the prefetch by verifying middleware consistency.

### Step 2: Diagnostic Header (x-nextjs-data)
Previously, we simulated a "swallowed" header check.
`-H "x-nextjs-data: 1"`
This header is processed *inside* `middleware.ts` (if logic exists). If you see the effect (e.g., a specific redirect header), you know middleware **ran**. If you don't see it (but get content), middleware was **bypassed**.

## 3. Why it fails here
In our current deployment:
1.  **Middleware Logic**: explicitly checks `auth_token`.
2.  **Next.js Version**: 13.4.19 patches some specific vectors of this, or the default `output: 'standalone'` and cache configuration prevents the simple single-request bypass.
3.  **Redirects**: Since the middleware returns a `redirect` (not a `rewrite` or `next`), the "cached response" is the redirect itself. The vulnerability is most potent when the middleware is supposed to *allow* access (returning `next()`) but the cache serves a *different* version, or vice versa. Here, the "default" for unauth is Block, so caching "Block" is safe.

To truly exploit this, one usually needs to find a way to make the "Prefetch" return a 200 (e.g., by finding a path that allows access) and then use that cached 200 for a protected path (Cache Key Collision).


